# this is the code generated by DeepSeek
# i can not share the chat
class Customer:
    def __init__(self, id: int, name: str, telephone: int):
        self.__id = id
        self.__name = name
        self.__telephone = telephone

    @property
    def id(self):
        return self.__id

    @id.setter
    def id(self, value: int):
        if not isinstance(value, int):
            raise ValueError("ID must be an integer.")
        self.__id = value

    @property
    def name(self):
        return self.__name

    @name.setter
    def name(self, value: str):
        if not isinstance(value, str):
            raise ValueError("Name must be a string.")
        self.__name = value

    @property
    def telephone(self):
        return self.__telephone

    @telephone.setter
    def telephone(self, value: int):
        if not isinstance(value, int):
            raise ValueError("Telephone must be an integer.")
        self.__telephone = value

    def __str__(self):
        return f"Customer {self.__id}: {self.__name} - {self.__telephone}"


class Resource:
    def __init__(self, id: str, name: str, year: int):
        self.__id = id
        self.__name = name
        self.__year = year
        self.__status = "available"

    @property
    def id(self):
        return self.__id

    @id.setter
    def id(self, value: str):
        if not isinstance(value, str):
            raise ValueError("ID must be a string.")
        self.__id = value

    @property
    def name(self):
        return self.__name

    @name.setter
    def name(self, value: str):
        if not isinstance(value, str):
            raise ValueError("Name must be a string.")
        self.__name = value

    @property
    def year(self):
        return self.__year

    @year.setter
    def year(self, value: int):
        if not isinstance(value, int):
            raise ValueError("Year must be an integer.")
        self.__year = value

    @property
    def status(self):
        return self.__status

    def borrow(self):
        if self.__status == "available":
            self.__status = "borrowed"
            return True
        return False

    def returning(self):
        if self.__status in ["borrowed", "under repair"]:
            self.__status = "available"
            return True
        return False

    def repair(self):
        if self.__status == "available":
            self.__status = "under repair"
            return True
        return False

    def __str__(self):
        return f"{self.__id}: '{self.__name}' ({self.__year})"


class Book(Resource):
    def __init__(self, id: int, name: str, author: str, year: int, department: str):
        super().__init__(f"B{id}", name, year)
        self.__author = author
        self.__department = department

    @property
    def author(self):
        return self.__author

    @author.setter
    def author(self, value: str):
        if not isinstance(value, str):
            raise ValueError("Author must be a string.")
        self.__author = value

    @property
    def department(self):
        return self.__department

    @department.setter
    def department(self, value: str):
        if not isinstance(value, str):
            raise ValueError("Department must be a string.")
        self.__department = value

    @property
    def type(self):
        return "Book"

    def __str__(self):
        return f"{self.id}: '{self.name}' by {self.__author} ({self.year})"


class Disk(Resource):
    def __init__(self, id: int, name: str, singer: str, year: int):
        super().__init__(f"D{id}", name, year)
        self.__singer = singer

    @property
    def singer(self):
        return self.__singer

    @singer.setter
    def singer(self, value: str):
        if not isinstance(value, str):
            raise ValueError("Singer must be a string.")
        self.__singer = value

    @property
    def type(self):
        return "Disk"

    def __str__(self):
        return f"{self.id}: '{self.name}' by {self.__singer} ({self.year})"


class Magazine(Resource):
    def __init__(self, id: int, name: str, publisher: str, serialNumber: int):
        super().__init__(f"M{id}", name, serialNumber)
        self.__publisher = publisher
        self.__serialNumber = serialNumber

    @property
    def publisher(self):
        return self.__publisher

    @publisher.setter
    def publisher(self, value: str):
        if not isinstance(value, str):
            raise ValueError("Publisher must be a string.")
        self.__publisher = value

    @property
    def serialNumber(self):
        return self.__serialNumber

    @serialNumber.setter
    def serialNumber(self, value: int):
        if not isinstance(value, int):
            raise ValueError("Serial number must be an integer.")
        self.__serialNumber = value

    @property
    def type(self):
        return "Magazine"

    def __str__(self):
        return f"{self.id}: '{self.name}' by {self.__publisher} â€“ number {self.__serialNumber}"


class Library:
    def __init__(self):
        self.__customers = []
        self.__resources = []
        self.__borrowing = {}

    @property
    def customers(self):
        return self.__customers

    @property
    def resources(self):
        return self.__resources

    @property
    def borrowing(self):
        return self.__borrowing

    def add(self, item):
        if isinstance(item, Customer):
            if any(customer.id == item.id for customer in self.__customers):
                raise ValueError("Customer with this ID already exists.")
            self.__customers.append(item)
        elif isinstance(item, (Book, Disk, Magazine)):
            if any(resource.id == item.id for resource in self.__resources):
                raise ValueError("Resource with this ID already exists.")
            self.__resources.append(item)
        else:
            raise ValueError("Invalid item type.")

    def removeCustomer(self, id: int):
        customer = next((c for c in self.__customers if c.id == id), None)
        if not customer:
            return False
        if id in self.__borrowing and self.__borrowing[id]:
            raise ValueError("Customer has borrowed resources and cannot be removed.")
        self.__customers.remove(customer)
        return True

    def removeResource(self, id: str):
        resource = next((r for r in self.__resources if r.id == id), None)
        if not resource:
            return False
        if resource.status != "available":
            raise ValueError("Resource is not available and cannot be removed.")
        self.__resources.remove(resource)
        return True

    def borrowResource(self, customer: Customer, resource: Resource):
        if not isinstance(customer, Customer) or not isinstance(resource, Resource):
            raise ValueError("Invalid customer or resource.")
        if customer not in self.__customers or resource not in self.__resources:
            raise ValueError("Customer or resource not registered in the library.")
        if resource.status != "available":
            raise ValueError("Resource is not available for borrowing.")
        if resource.borrow():
            if customer.id not in self.__borrowing:
                self.__borrowing[customer.id] = []
            self.__borrowing[customer.id].append(resource)
            return True
        return False

    def returnResource(self, customer: Customer, resource: Resource):
        if not isinstance(customer, Customer) or not isinstance(resource, Resource):
            raise ValueError("Invalid customer or resource.")
        if customer not in self.__customers or resource not in self.__resources:
            raise ValueError("Customer or resource not registered in the library.")
        if customer.id not in self.__borrowing or resource not in self.__borrowing[customer.id]:
            raise ValueError("Customer did not borrow this resource.")
        if resource.returning():
            self.__borrowing[customer.id].remove(resource)
            return True
        return False

    def availables(self, resource_type: str = None):
        if resource_type:
            return [resource for resource in self.__resources if resource.status == "available" and resource.type == resource_type]
        else:
            return {
                "Book": [resource for resource in self.__resources if resource.status == "available" and resource.type == "Book"],
                "Disk": [resource for resource in self.__resources if resource.status == "available" and resource.type == "Disk"],
                "Magazine": [resource for resource in self.__resources if resource.status == "available" and resource.type == "Magazine"]
            }


if __name__ == "__main__":
    library = Library()

    book1 = Book(1, "The Life", "Moshe", 2004, "Biography")
    disk1 = Disk(1, "Home", "Hanan", 2011)
    magazine1 = Magazine(1, "Finances", "Kalkalist", 501)

    library.add(book1)
    library.add(disk1)
    library.add(magazine1)

    customer1 = Customer(123, "Arieh", 456)
    library.add(customer1)

    library.borrowResource(customer1, book1)

    print("Available resources after borrowing:")
    print(library.availables())