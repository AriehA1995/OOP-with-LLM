# This code is generated by Gemini
# Some correction was made to allow the code to run without errors, but most of it is originally from there
# https://g.co/gemini/share/595d3c9116c0
class Customer:
    def __init__(self, id, name, telephone):
        self.__id = id
        self.__name = name
        self.__telephone = telephone

    @property
    def id(self):
        return self.__id

    @id.setter
    def id(self, value):
        if not isinstance(value, int):
            raise TypeError("ID must be an integer")
        self.__id = value

    # Similarly, define getters and setters for name and telephone, ensuring type checks
    @property
    def name(self):
        return self.__name

    @name.setter
    def name(self, value):
        if not isinstance(value, str):
            raise TypeError("Name must be a string")
        self.__name = value

    @property
    def telephone(self):
        return self.__telephone

    @telephone.setter
    def telephone(self, value):
        if not isinstance(value, int):
            raise TypeError("Telephone number must be an integer")
        self.__telephone = value

    def __str__(self):
        return f"Customer {self.__id}: {self.__name} - {self.__telephone}"


class Resource:
    def __init__(self, id, name, status):
        self.__id = id
        self.__name = name
        self.__status = status
    
    @property
    def name(self):
        return self.__name

    @property
    def status(self):
        return self.__status

    # Common methods for all resources
    def borrow(self):
        if self.__status == "available":
            self.__status = "borrowed"
            return True
        return False

    def returning(self):
        if self.__status in ["borrowed", "under repair"]:
            self.__status = "available"
            return True
        return False

    def repair(self):
        if self.__status == "available":
            self.__status = "under repair"
            return True
        return False

    def __str__(self):
        return f"{self.__id}: '{self.__name}' - {self.__status}"
    # ... other common methods and properties

class Book(Resource):
    """
    מחלקה לייצוג ספר בספרייה.

    תכונות:
    * __id: מזהה ייחודי לספר (למשל, B123)
    * __name: שם הספר
    * __author: מחבר הספר
    * __year: שנת ההוצאה לאור
    * __department: מחלקה בספרייה
    * __status: מצב הספר (זמין, מושאל, בתיקון)
    """

    def __init__(self, id, name, author, year, department):
        """
        בנאי המחלקה.

        ארגומנטים:
        * id: מזהה הספר (מחרוזת התחילה ב-B)
        * name: שם הספר
        * author: מחבר הספר
        * year: שנת ההוצאה לאור (מספר שלם)
        * department: מחלקה בספרייה (מחרוזת)
        """

        if not isinstance(id, int):
            raise TypeError("ID must be an integer")
        if not isinstance(year, int):
            raise TypeError("Year must be an integer")

        super().__init__(f"B{id}", name, "available")
        self.__id = id
        self.__author = author
        self.__year = year
        self.__department = department

    @property
    def author(self):
        return self.__author

    @author.setter
    def author(self, value):
        if not isinstance(value, str):
            raise TypeError("Author must be a string")
        self.__author = value

    @property
    def year(self):
        return self.__year

    @year.setter
    def year(self, value):
        if not isinstance(value, int):
            raise TypeError("Year must be an integer")
        self.__year = value

    @property
    def department(self):
        return self.__department

    @department.setter
    def department(self, value):
        if not isinstance(value, str):
            raise TypeError("Department must be a string")
        self.__department = value

    def __str__(self):
        return f"B{self.__id}: '{self.name}' by {self.__author} ({self.__year})"

class Disk(Resource):
    """
    מחלקה לייצוג דיסק בספרייה.

    תכונות:
    * __id: מזהה ייחודי לדיסק (מספר שלם)
    * __name: שם הדיסק
    * __singer: זמר הדיסק
    * __year: שנת ההוצאה לאור
    * __status: מצב הדיסק (זמין, מושאל, בתיקון)
    """

    def __init__(self, id, name, singer, year):
        """
        בנאי המחלקה.

        ארגומנטים:
        * id: מזהה הדיסק (מספר שלם)
        * name: שם הדיסק
        * singer: זמר הדיסק
        * year: שנת ההוצאה לאור (מספר שלם)
        """

        if not isinstance(id, int):
            raise TypeError("ID must be an integer")
        if not isinstance(year, int):
            raise TypeError("Year must be an integer")

        super().__init__(f"D{id}", name, "available")
        self.__id = id
        self.__singer = singer
        self.__year = year

    @property
    def singer(self):
        return self.__singer

    @singer.setter
    def singer(self, value):
        if not isinstance(value, str):
            raise TypeError("Singer must be a string")
        self.__singer = value

    @property
    def year(self):
        return self.__year

    @year.setter
    def year(self, value):
        if not isinstance(value, int):
            raise TypeError("Year 1  must be an integer")
        self.__year = value

    def __str__(self):
        return f"D{self.__id}: '{self.name}' by {self.__singer} ({self.__year})"

class Magazine(Resource):
    """
    מחלקה לייצוג מגזין בספרייה.

    תכונות:
    * __id: מזהה ייחודי למגזין (מספר שלם)
    * __name: שם המגזין
    * __publisher: הוצאת המגזין
    * __serialNumber: מספר גיליון
    * __status: מצב המגזין (זמין, מושאל, בתיקון)
    """

    def __init__(self, id, name, publisher, serialNumber):
        """
        בנאי המחלקה.

        ארגומנטים:
        * id: מזהה המגזין (מספר שלם)
        * name: שם המגזין
        * publisher: הוצאת המגזין
        * serialNumber: מספר גיליון (מספר שלם)
        """

        if not isinstance(id, int):
            raise TypeError("ID must be an integer")
        if not isinstance(serialNumber, int):
            raise TypeError("SerialNumber must be an integer")

        super().__init__(f"M{id}", name, "available")
        self.__id = id
        self.__publisher = publisher
        self.__serialNumber = serialNumber

    @property
    def publisher(self):
        return self.__publisher

    @publisher.setter
    def publisher(self, value):
        if not isinstance(value, str):
            raise TypeError("Publisher must be a string")
        self.__publisher = value

    @property
    def serialNumber(self):
        return self.__serialNumber

    @serialNumber.setter
    def serialNumber(self, value):
        if not isinstance(value, int):
            raise TypeError("SerialNumber must be an integer")
        self.__serialNumber = value

    def __str__(self):
        return f"M{self.__id}: '{self.name}' by {self.__publisher} - number {self.__serialNumber}"

class Library:
    def __init__(self):
        self.__customers = []
        self.__resources = []
        self.__borrowing = {}

    @property
    def resources(self):
        return self.__resources.copy()  # מחזיר עותק של הרשימה כדי למנוע שינויים חיצוניים

    @property
    def customers(self):
        return self.__customers.copy()

    @property
    def borrowing(self):
        return self.__borrowing.copy()

    # ... methods for adding, removing, borrowing, and returning resources
    def add(self, item):
        # ... (בדיקות קיום קודם, סוג האובייקט וכו')
        if isinstance(item, Customer):
            self.__customers.append(item)
        elif isinstance(item, Resource):
            self.__resources.append(item)
        else:
            raise TypeError("Invalid item type")

    def removeCustomer(self, customer_id):
        # ... (בדיקות קיום הלקוח, חובות וכו')
        for i, customer in enumerate(self.__customers):
            if customer.id == customer_id:
                if customer_id in self.__borrowing:
                    raise ValueError("Customer has borrowed resources")
                del self.__customers[i]
                del self.__borrowing[customer_id]
                return True
        return False
    
    def removeResource(self, resource_id):
        for i, resource in enumerate(self.__resources):
            if resource.id == resource_id:
                del self.__resources[i]
                # הסרת המשאב מכל ההשאלות
                for customer_id, borrowed_resources in self.__borrowing.items():
                    if resource in borrowed_resources:
                        borrowed_resources.remove(resource)
                return True
        return False

    def borrowResource(self, customer, resource):
        if resource not in self.__resources:
            raise ValueError("Resource not found")
        if resource.status != "available":
            raise ValueError("Resource is not available")
        resource.borrow()
        if customer in self.__customers:
            if customer in self.__borrowing:
                self.__borrowing[customer].append(resource)
            else:
                self.__borrowing[customer] = [resource]
        else:
            raise ValueError("Customer not found")

    def returnResource(self, customer, resource):
        if resource not in self.__resources:
            raise ValueError("Resource not found")
        if resource.status != "borrowed":
            raise ValueError("Resource is not borrowed")
        if customer not in self.__customers:
            raise ValueError("Customer not found")
        if customer not in self.__borrowing or resource not in self.__borrowing[customer]:
            raise ValueError("Customer has not borrowed this resource")
        resource.return_resource()
        self.__borrowing[customer].remove(resource)
        if not self.__borrowing[customer]:
            del self.__borrowing[customer]

    def availables(self, resource_type=None):
        available_resources = []
        for resource in self.__resources:
            if resource.status == "available":
                if resource_type is None or isinstance(resource, resource_type):
                    available_resources.append(resource)
        return available_resources

    def get_customer_borrowings(self, customer_id):
        if customer_id in self.__borrowing:
            return self.__borrowing[customer_id]
        return []

if __name__ == "__main__":
    # Create a library, add resources and customers, and perform actions
    library = Library()

    # יצירת משאבים
    book1 = Book(123, "הHobbit", "J.R.R. Tolkien", 1937, "פנטזיה")
    book2 = Book(456, "שר הטבעות", "J.R.R. Tolkien", 1954, "פנטזיה")
    disk1 = Disk(789, "אלבום רוק", "להקה מפורסמת", 2022)

    # הוספת משאבים לספרייה
    library.add(book1)
    library.add(book2)
    library.add(disk1)

    # יצירת לקוח
    customer1 = Customer(1, "אריאל", "0541234567")
    library.add(customer1)  # הנחנו שיש פונקציה להוספת לקוח

    # השאל ספר
    library.borrowResource(customer1, book1)

    # הדפסת המשאבים הזמינים
    available_resources = library.availables()
    print("משאבים זמינים להשאלה:")
    for resource in available_resources:
        print(resource)